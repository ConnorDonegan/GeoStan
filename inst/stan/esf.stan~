functions {
#include parts/priors.stan
}
data {
#include parts/data.stan
// esf data
  int<lower=0> dev; // number of eigenvectors 
  matrix[n, dev] EV; // the eigenvectors
  real<lower=0> scale_global;  // horseshoe parameters
  real<lower=0> slab_scale;
  real<lower=0> slab_df;
}

transformed data {
#include parts/trans_data.stan
}

parameters {
// ESF parameters
  real<lower=0> aux1_global;
  real<lower=0> aux2_global;
  vector<lower=0>[dev] aux1_local;
  vector<lower=0>[dev] aux2_local;
  real<lower=0> caux;
  vector[dev] z;
#include parts/params.stan
}

transformed parameters {
  matrix[n, dx_all] x_all;
  vector[n] offset;
  vector[n] f;
  vector[dev] beta_ev;  
  real error_scale;
  if (dx_obs) x_all[,x_obs_idx] = x_obs;
  if (dx_me_prop) x_all[,x_me_prop_idx] = x_true_prop;
  if (dx_me_cont) x_all[,x_me_cont_idx] = x_true_cont;
  if (!model_offset) offset = offset_obs;
  if (is_poisson) offset = log(offset);
  if (has_sigma) {
    error_scale = sigma[1];
      } else {
    error_scale = 1;
      }
  beta_ev = rhs_prior(dev, z, aux1_global, aux2_global, aux1_local, aux2_local, caux, scale_global, slab_scale, error_scale);
  f = offset + intercept + EV * beta_ev; 
  if (has_re) {
    for (i in 1:n) {
      f[i] += alpha_tau[has_re] * alpha_re_tilde[id[i]];
   }
  }  
  if (dwx) {
   if (has_me) {
      for (i in 1:dwx) {
     f += csr_matrix_times_vector(n, n, w, v, u, x_all[,wx_idx[i]]) * gamma[i];
     }
   } else {
      f += WX * gamma;
      }
  } 
  if (dx_all) f += x_all * beta;
  if (is_binomial) f = inv_logit(f);
}

model {
// RHS prior model
  z ~ std_normal();
  aux1_local ~ normal(0, 1);
  aux2_local ~ inv_gamma(0.5, 0.5);// .5 * nu_local, .5 * nu_local, nu_local = 1
  aux1_global ~ std_normal();
  aux2_global ~ inv_gamma(0.5, 0.5); // .5 * nu_local, .5 * nu_global, both = 1
  caux ~ inv_gamma(0.5*slab_df, 0.5*slab_df);
#include parts/model.stan
}

generated quantities {
  vector[n] esf;
#include parts/gen_quants.stan
  for (i in 1:n) {
      esf[i] = EV[i] * beta_ev;
  }
}

