---
title: "Setting prior distributions"
author: "Connor Donegan"
output:
  rmarkdown::html_vignette
bibliography: bib.bib
header-includes:
   - \usepackage{amsmath}
vignette: >
  %\VignetteIndexEntry{Setting prior distributions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  fig.align = "center",
  fig.height = 2.5,
  fig.width = 6,
  comment = "#>"
)
options(mc.cores = parallel::detectCores())
#> run with:  sudo Rscript -e "rmarkdown::render('setting-priors.Rmd')"
```

This vignette provides instruction for setting prior distributions for **geostan** models. While **geostan** will set priors automatically if you do not provide them, users are encouraged to set priors based on domain-specific knowledge. 

## Getting started

Load the **geostan**, **ggplot2**, and **sf** packages:

```{r}
library(geostan)
library(ggplot2)
library(sf)  
```
 Given a url to a shapefile, the `geostan::get_shp` function will download the data and unzip it into your working directory. Download the `nepal` dataset with information on social indicators for 75 districts of Nepal (hosted by [GeoDa](https://geodacenter.github.io/)):

```{r}
# saving to a temporary directory
folder <- tempdir()
url <- "https://geodacenter.github.io/data-and-lab//data/nepal.zip"
get_shp(url, folder)
nepal <- st_read(folder, "nepal")
```
We will reference per-capita income (PCI) `pcinc` and the percentage of people not expected to survive beyond age 40 `lif40` (or "early mortality"). To work with a fixed example, consider a model that hypothesizes premature mortality rates to be a linear function of per-capita income
\begin{equation}
 \text{early_mortality}_i = \alpha + \beta * \text{PCI}_i + e_i
 \end{equation}
with $e_i$ an error term, and we want to obtain a probability distribution for each of the model's parameters conditional on the `nepal` data and background information. Note that the examples here are intended only to provide guidance on how to use particular features in the software, this vignette does not offer guidance on determining what prior parameters are appropriate.

## Default prior distributions

If you don't provide prior distributions **geostan** will set them for you and will print them out before fitting the model:

```{r}
 # refresh = 0 suppresses some of the printing from Stan
fit <- stan_glm(lif40 ~ pcinc, data = nepal, prior_only = TRUE, refresh = 0, cores = 1)
```

The intercept and coefficients are assigned Gaussian prior distributions centered on zero with scale parameter equal to $2 * s_y$ and $2*\frac{s_y}{s_x}$ respectively (with $s$ the sample standard deviation; similar to the default priors in the **rstanarm** package). For models with a Gaussian or Student's $t$ likelihood, the scale parameter $\sigma$ for the outcome is assigned a half-Student's $t$ model (truncated to be positive) with scale $2 * s_y$. 

```{r}
2 * sd(nepal$lif40) / sd(nepal$pcinc)
```
By setting `prior_only = TRUE` we tell Stan to sample from the prior distributions only, ignoring the likelihood of the data. We can visualize samples from the prior distributions:

```{r}
plot(fit)
```
We can also extract all the samples from prior distributions as a matrix:

```{r}
beta.samples <- as.matrix(fit, pars = "beta")
dim(beta.samples)
```
If we use the `centerx` (or `scalex`) arguments in `stan_glm` (or any of the **geostan** model fitting functions), the covariates will be centered (or scaled) before the priors are calculated, and the default prior for the intercept will be centered on the data mean $\bar{y}$ rather than zero:

```{r}
fit.c <- stan_glm(lif40 ~ pcinc, data = nepal, centerx = TRUE, refresh = 0, cores = 1)
```
Centering or scaling data often improves Stan's sampling speed, sometimes dramatically! 

The eigenvector spatial filter (ESF) models (see `geostan::stan_esf`) will also set priors automatically for the additional parameters needed to fit the spatial filter, specifically the coefficients `beta_ev` on the spatial eigenvectors. ESF models attempt to use a linear combination of the eigenvectors from a transformed spatial connectivity matrix to estimate latent spatial autocorrelation patterns. The Nepal model could be updated with a spatial filter as such:
\begin{equation}
  \text{early_mortality}_i = \alpha + EV_i * \beta_{EV} + \text{PCI}_i * \beta_{inc} + e_i
  \end{equation}
Each of the eigenvectors represent patterns of potential spatial autocorrelation. The challenge of ESF models is that they can have a very high number of parameters to estimate (one for each eigenvector) and often only a small number of them are far from zero.
The **geostan** package assigns a regularized horseshoe (RHS) prior model (@piironen_2017) to the coefficients `beta_ev`. This concentrates prior probability on zero, aggressively shrinking all of the coefficients to zero; but it also has heavy tails that open up where there is sufficient evidence of a non-zero coefficient, allowing a few parameters to escape the pull toward zero.

Again **geostan** will print its default priors before sampling from the model:

```{r}
C <- shape2mat(nepal)
fit.esf <- stan_esf(lif40 ~ pcinc, data = nepal, C = C, centerx = TRUE, prior_only = TRUE, refresh = 0, cores = 1)
```
We can plot samples from the prior distribution:

```{r}
plot(fit.esf, pars = "beta_ev[1]")
```
We can also draw samples from prior distribution of the spatial filter itself, which is a joint probability over `EV * beta_ev`, using `geostan::spatial`::

```{r}
sf <- spatial(fit.esf, summary = FALSE)
dim(sf)
```
Each of the coefficients has the same marginal probability as `beta_ev[1]`, but samples from the joint prior probability of the coefficients `beta_ev` reveal that the default prior, which is based on the number of observations and the degree of autocorrelation in the outcome variable, assigns high probability on their being some kind of spatial autocorrelation. Each of the samples exhibit a different pattern, arising from various linear combinations of eigenvectors:

```{r}
n.samples <- nrow(sf)
idx <- sample(n.samples, size = 1)
ggplot(nepal) +
  geom_sf(aes(fill = sf[idx, ])) +
  scale_fill_gradient2() +
  theme_void()

idx <- sample(n.samples, size = 1)
ggplot(nepal) +
  geom_sf(aes(fill = sf[idx, ])) +
  scale_fill_gradient2() +
  theme_void()
```
The default priors for `geostan::stan_esf` are designed to work well for the data provided, but they are not perfect. The best evaluation of the ESF models is to examine the residuals for spatial autocorrelation using `geostan::moran_plot` or `geostan::sp_diag`.

## Setting priors: GLM

This section shows how to set priors on the intercept, coefficients, scale term $\sigma$, and other parameters that apply to some or all of the `stan_*` model fitting functions. The prior models are fixed (i.e. you currently cannot change the prior on the intercept from a Gaussian to Student's $t$) but you can and generally should provide your own values for the parameters.

### Intercept

To set the prior parameters for the intercept provide the values for the location $\mu$ and scale $\sigma$ of the Gaussian distribution to the `prior_intercept` argument. The following code sets the prior for the intercept to a Gaussian distribution with mean 0 and scale 5:

```{r eval = FALSE}
fit <- stan_glm(lif40 ~ pcinc, data = nepal, prior_intercept = c(0, 5))
```

### Coefficients

Priors for coefficients need to be provided in a matrix or data frame and passed to the `prior` argument. Provide two columns---location and scale---and a row for each variable in their order of appearance in the model formula. In this case there is one variable, so if we wish to set its prior to a Gaussian with mean 2 and scale 2 we would use:

```{r eval = FALSE}
fit <- stan_glm(lif40 ~ pcinc, data = nepal, prior = data.frame(location = 2, scale = 2))
```
If we had three covariates and wished to assigned the same prior to all of them the `prior` argument would then look like `prior = data.frame(location = c(2, 2), scale = c(2, 2))`.

### Outcome scale

The scale parameter $\sigma$ is assigned a half-Student's $t$ prior, which is truncated at zero (i.e. only positive values will be assigned non-zero probability). The Student's $t$ distribution has three parameters: degrees of freedom, location, and scale. So if we wish to set the prior to Student's $t$ with 10 degrees of freedom, location 0, and scale 2, we would provide the following:
```{r eval = FALSE}
fit <- stan_glm(lif40 ~ pcinc, data = nepal, prior_sigma = c(10, 0, 2))
```
### Student's $t$ likelihood

Often times the Gaussian model is unsatisfactory because there appear to be 'outliers' that may be exerting undue influence on the results. Since the Student's $t$ likelihood has heavier tails, such outliers will exert less influence when `family = student_t()`. The prior for the degrees of freedom for the likelihood is a Gamma distribution and it can be set using the `prior_nu` argument in `stan_glm`. The default, for instance, could be set manually like this:
```{r eval = FALSE}
fit <- stan_glm(lif40 ~ pcinc, data = nepal, family = student_t(), prior_nu = c(3, 0.2))
```
which for reference looks like this:
```{r}
g <- rgamma(n = 30e3, 3, 0.2)
hist(g, main = "Gamma(3, 0.2)")
```

### Varying intercepts

All of the models have the option to include a varying intercept term. These are similar to adding an indicator or dummy variable for each region, for instance, or any other geographic scale. However, they use hierarchical modeling to partially pool information across observations (often called 'random effects' terms, which is misleading). For count data especially, this offers a way to evaluate rates of occurence while remaining attentive to the instability of rates when denominators are small. Generically, these models assign low probability to 'extreme' values, but what is considered 'extreme' or implausible is defined by a Gaussian distribution with parameters that are inferred from the data. The varying intercepts $\alpha_{[j]}$ are deviations from the global intercept, and their prior model is equivalent to:
$$
\alpha_{[j]} \sim Gauss(0, \tau_\alpha) \\
\tau_\alpha \sim Student^{+}(\text{degrees of freedom, location, scale})
$$
with positively-constrained Student's $t$ prior for the scale. If we were to estimate the mean `lif40` for each of the 14 regions in the `nepal` data (found in the `name_2` variable), we would use the `re` argument to specify the regional grouping variable and override the default prior parameters for $\alpha_\tau$, if desired, using the `prior_tau` argument:

```{r eval = FALSE}
fit <- stan_glm(lif40 ~ 1, re = ~ name_2, data = nepal, prior_tau = c(15, 0, 5))
```

## Setting priors: ESF

As discussed above, `geostan::stan_esf` models assign the regularized horseshoe (RHS) prior model to the coefficients of the spatial filter. The RHS model has three parameters that need to be set. First is a global scale parameter which should reflect our initial information on how sparse the model should be: setting `scale_global` near zero will impose more sparsity, and moving it towards 1 relaxes the sparsity of the model. If a model shows residual spatial autocorrelation, relaxing the degree of sparsity may help by allowing spatial filter to expand and absorb more of the autocorrelation pattern. Approximating the autocorrelation patterns in data with strong spatial autocorrelation typically requires greater numbers of eigenvectors, and this informs **geostan**'s default prior settings (based on equations from @chun_2016; see @donegan_2020). The remaining parameters to set are the degrees of freedom and scale for a Student's $t$ prior which is applied to any of the "large" parameter estimates that escape the shrinkage to zero. One can view the RHS model as a combination of a spike at zero and slabs extending outwards; the Student's $t$ model determines the width of the slabs.

The RHS prior parameters can be set by providing a named vector to the `prior_rhs` argument, with elements `scale_global` and `slab_df` and `slab_scale` (for the Student's $t$ slab):

```{r eval = FALSE}
fit <- stan_esf(lif40 ~ pcinc, data = nepal, C = C, prior_rhs = c(scale_global = 0.6, slab_df = 10, slab_scale = 20))
```
For some intuition on the scale of the slab, you have to know the scale of the eigenvectors and the outcome variable. All of the eigenvectors have the same scale, which in this case is:

```{r}
EV <- make_EV(C)
sd(EV[,1])

sd(nepal$lif40)
```

The default prior for the slab is `slab_df = 15` and `slab_scale = 0.5 * sd(y) / sd(EV[,1])`. The default prior for the `scale_global` parameter is described in @donegan_2020.

## Setting priors: ICAR

The Intrinsic Conditional Autoregressive (ICAR) models are based on the Stan code developed in @morris_2019. In each of the available model options (`type = c("icar", "bym", "bym2")`), a parameter vector `phi` is assigned the ICAR prior (which places high prior probability on smooth spatial trends). The model is fixed, with no priors available to set.

To implement the BYM2 model introduced in @riebler_2016 and implemented in Stan by @morris_2019, you must provide an additional `scale_factor` term using the **INLA** package (see [here](https://www.r-inla.org/download-install) for installation instructions).

The following code chunk demonstrates how to calculate the `scale_factor` argument given a spatial connectivity matrix C, the `geostan::prep_icar_data` function, and a user-defined function `c_scale`:

```{r eval = FALSE}
library(INLA)

#' create scale factor for BYM2 model
#' C must be an N by N connectivity matrix
c_scale <- function(C) {
    N <- nrow(C)
    adj.matrix <- Matrix::Matrix(C, sparse = TRUE)
    Q =  Diagonal(N, rowSums(adj.matrix)) - adj.matrix
    Q_pert = Q + Diagonal(N) * max(diag(Q)) * sqrt(.Machine$double.eps)
    Q_inv = INLA::inla.qinv(Q_pert, constr=list(A = matrix(1,1,N),e=0))
    scale_factor <- exp(mean(log(diag(Q_inv))))
    return (scale_factor)
}

C <- shape2mat(nepal)
icar.data <- prep_icar_data(C)

scale_factor <- vector(mode = "numeric", length = n)
for (j in 1:k) {
    g.idx <- which(icar.data$comp.id == j) 
    if (length(g.idx) == 1) {
        scale_factor[g.idx] <- 1 
        next
    }    
    Cg <- C[g.idx, g.idx] 
    scale.j <- c_scale(Cg)
    scale_factor[g.idx] <- scale.j
}
```

The `scale_factor` is then passed to `stan_icar` for the BYM2 model, as in:

```{r eval = FALSE}
fit <- stan_icar(y ~ offset(log_population), data = data, type = "bym2", C = C, scale_factor = scale_factor)
```

## Setting priors: CAR

The `stan_car` model follows the Stan code created by @joseph_2016. The only adjustable parameter specific to this model is the Gamma prior on the precision parameter for the spatial component `phi` (coded as `phi_tau`). The default Gamma prior is Gamma (2, 2). If you wish to change it you can do so by updating `prior_phi_precision`, such as

```{r eval = FALSE}
fit <- stan_car(y ~ offset(log_population), data = data, C = C, prior_phi_precision = c(1, 1))
```


```{r show = FALSE}
# delete the nepal data 
unlink("nepal", recursive = TRUE)
```

## References

