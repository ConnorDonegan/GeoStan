apply(mu, 1, function(r) r + offset)
head(newdata)
newdata=sentencing@data
head(newdata)
re_term
re_idx
head(newdata)
newdata=sentencing@data
head(newdata)
fit$re$Data
head(fit$re$Data)
newdata$id
newdata=sentencing@data
head(newdata)
head(newdata)
tail(newdata)
dim(mu)
dim(alpha_re)
?apply
?sweep
dim(mu)
length(offset)
b
b
a
a
dim(mu)
offset=-1
mu + mu2
mu-mu2
offset
offset <- rep(-1, times = nrow(newdata))
offset
offset[1:3]
offset[1:3] <- +1
mu - mu2
head(mu - mu2)
offset
dim(mu)
newdata=sentencing@data
head(newdata)
tail(newdata)
dim(alpha_re)
dim(mu)
dim(mu)
mu[1,]
hist(mu[1,])
hist(exp(mu[1,]))
plot(sentencing$sents, exp(mu[1,]))
abline(0,1)
dim(sp)
head(sp)
plot(sentencing$sents, exp(mu[1,]))
abline(0,1)
plot(sentencing$sents, exp(mu[2,]))
abline(0,1)
plot(sentencing$sents, exp(mu[3,]))
abline(0,1)
fit
fit$spatial
spatial(fit)
fit$spatial
fit.pois$spatial
fit$spatial
invlogit
inv.logit
inv_logit
inv_logit(0)
inv_logit(1)
inv_logit(1e6)
inv_logit(1e3)
inv_logit(100)
inv_logit(200)
inv_logit(-100)
inv_logit(-1e3)
inv_logit(-2e3)
inv_logit(-6e6)
inv_logit(646)
inv_logit(6e6)
dim(p)
dim(pstan)
dim(p)
dim(p)
dim(pstan)
?hist
?hist
?base::hist
library(gridExtra)
grid.arrange(a,b,ncol=2)
fit=fit2
fit2$slx
newdata=ohio
dim(x)
head(x)
dim(beta)
W=shape2mat(ohio, style = "W")
dim(W)
fit2
)
head(x)
names(x)
max(as.numeric(pstan))
max(as.numeric(p))
?geom_density
fit2$priors
sd(make_EV(C))
sd(make_EV(C)[,1])
sd(ohio$gop_growth)
6/.1
1/.1
fit2$priors
plot(fit2,"beta_ev")
plot(fit2,"beta_ev")
fit=fit.pois
newdata=sentencing@data
rm(W)
N
link
family
offset
head(x)
dim(x)
mu
fit$re
fit$re
fit$spatial
library(bayesplot)
fit2
offset
rm(list=ls())
fit=fit2
newdata=ohio
N
samples
samples=500
family
link
offset
fit$slx
class(fit$slx)
spatial
spatial=TRUE
fit
head(x)
hist(mu[1,])
names(fit)
x <-
fit$priors
plot(fit2,"intercept")
?rt
dim(mu)
?geostan::spatial
p
plot(p,p2)
abline(0,1,col='red')
?qqPlot
?qqline
qqplot(as.numeric(preds), as.numeric(pstan))
stan_esf
head(ohio)
names(ohio)
ohio$county
fit2$re$Data
fit2$re
fit2$re$data
newdata=ohio
fit=fit2
re_idx
names(ohio)[3]
fit$re$Data
fit$re$data
newdata=ohio
fit=fit2
plot(fit, pars="alpha_re")
names(ohio)
?stan_glm
w
fit=fit2
newdata=ohio
idx
y
fit$formula[2]
fit$formula[[2]]
mode.frame(fit$formula, fit$data)
model.frame(fit$formula, fit$data)
model.frame(fit$formula, as.data.frame(fit$data))
head(fit$data)
stan_glm
frame<-model.frame(fit$formula, newdata)
head(frame)
model.matrix(gop_growth ~ 1)
fit$formula
f=fit$formula
f[1]
f[[2]]
f[-2]
f=cbind(trump_2016, total_2016-trump_2016) ~ 1
x=model.matrix(f,ohio)
head(x)
x=model.frame(f,ohio)
head(x)
x[[1]]
head(x[[1]]
)
stan_glm
?model.outcome
?model.extract
trials
p
pstan
hist(p)
hist(pstan)
a=hist(p);b=hist(pstan)
a=ggplot()+geom_histogram(aes(x=as.numeric(p)))
b=ggplot()+geom_histogram(aes(x=as.numeric(pstan)))
?bayesplot
moran_plot(resid(fit)$mean, W)
moran_plot(resid(fit)$mean, W)
p[1:10,]
tail(p <-
tail(p)
p[1:10,]
fit$family
fit$family$link
head(p)
hist(p)
hist(pstan)
pstan
fit$formula
hist(p)
with(ohio, hist(trump_2016/total_2016))
head(pstan)
sweep(pstan, 2, trials)
sweep(pstan,2,trials,"/")
a=sweep(pstan,2,trials,"/")
hist(a)
hist(p <-
hist(p)
hist(p)
hist(p)
hist(p)
p
hist(p)
c
warnings()
hist(p)
?rbinom
rbinom(10, size=rep(10,times=10), prob = rep(.5,times=10))
rbinom(10, size=rep(10,times=10), prob = rep(.5,times=10))
dim(p)
.pp_binomial(mu,trials)
trials
class(trials)
length(trials)
.pp_binomial(mu, as.integer(trials))
trials
t=trials/100
.pp_bonomial(mu,t)
.pp_binomial(mu,t)
rbinomial(ncol(mu), trials=trials,prob=mu[1,])
rbinom(ncol(mu), trials=trials,prob=mu[1,])
rbinom(ncol(mu), size = trials, prob = mu[1,])
trials
mu[1,]
mu[1,45:50]
rm(list=ls())
p
p
hist(p)
p
p
fit
hist(p)
hist(p)
dim(p)
a=data.frame(fact = c('a', 'b', 'c', 'd'), id = 1:4)
b=data.frame(fact = c('a','a','b','b'))
merge(b,a,by='fac')
merge(b,a,by='fact')
b=data.frame(fact = c('a','a','b','b','c'))
merge(b,a,by='fact')
class(fit)
inherits(fit, "geostan_fit")
posterior_predict <- function(fit, newdata, W, samples, predictive = TRUE, re_form = NULL, spatial = TRUE, seed) {
if (!inherits(fit, "geostan_fit")) stop ("fit must be of class geostan_fit.")
N <- nrow(as.matrix(fit))
if (!missing(seed)) set.seed(seed)
if (missing(samples)) samples <- N
if (samples > N) {
warning (paste0("Cannot draw more samples than were taken from the posterior. Using samples = ", N))
samples <- N
}
idx <- sample(N, samples)
if (missing(newdata)) {
preds <- as.matrix(fit, pars = "yrep")[idx,]
class(preds) <- append("ppd", class(preds))
return(preds)
} else {
newdata <- as.data.frame(newdata)
}
if (class(fit$slx) == "formula") {
if (missing(W)) stop ("You must provide spatial weights matrix W to calculate spatial lag of X terms (slx)")
if ( nrow(newdata) != nrow(W) | (nrow(newdata) != nrow(fit$data)) ) stop ("W, newdata, and fit$data must have same number of rows.")
}
family <- fit$family$family
link <- fit$family$link
if (family == "binomial") {
y <- model.response(model.frame(fit$formula, newdata))
trials <- as.integer(y[, 1] + y[, 2])
} else {
y <- as.character(fit$formula[[2]])
if (!y %in% names(newdata))  newdata[,y] <- 0
}
x <- model.matrix(fit$formula, data = newdata)
x <- remove_intercept(x)
offset <- model.offset(model.frame(fit$formula, newdata))
if (!is.null(offset) & family == "poisson") offset <- log(offset)
if ( spatial & (class(fit$slx) == "formula") ) {
Wx <- SLX(f = fit$slx, DF = newdata, SWM = W, cx = FALSE, sx = FALSE)
x <- cbind(Wx, x)
}
alpha <- as.matrix(fit, pars = "intercept")[idx,]
beta <- as.matrix(fit, pars = "beta")[idx,]
mu <- alpha + beta %*% t(x)
if (!is.null(offset)) mu <- sweep(mu, 2, offset, "+")
if (is.null(re_form) & !is.na(fit$re[1])) {
newdata$order <- 1:nrow(newdata)
re_term <- as.character( fit$re$formula[[2]] )
re_idx <- which( names(newdata) == re_term )
if ( !all(newdata[,re_idx] %in% fit$re$data$id) ) stop ("New levels for the random effects term are not allowed. Find fitted levels in fit$re$data$id.")
names(newdata)[re_idx] <- "id"
newdata <- merge(newdata, fit$re$data, by = "id", sort = FALSE)
newdata <- newdata[order(newdata$order),]
alpha_re <- as.matrix(fit, pars = "alpha_re")[idx,]
alpha_re <- alpha_re[,paste0("alpha_re[",newdata$idx,"]")]
mu <- mu + alpha_re
}
if (spatial & !fit$spatial$method %in% c("None", "none", "Exchangeable")) {
if (nrow(fit$data) != nrow(newdata)) stop ("If spatial = TRUE, newdata must contain the same number of observations as the original data (i.e. nrow(fit$data)).")
sp <- spatial(fit, summary = FALSE)[idx,]
mu <- mu + sp
}
if (link == "log") mu <- exp(mu)
if (link == "logit") mu <- inv_logit(mu)
if (!predictive) return (mu)
if (family == "gaussian") {
sigma <- as.matrix(fit, pars = "sigma")[idx,]
preds <- .pp_gaussian(mu, sigma)
}
if (family == "student_t") {
sigma <- as.matrix(fit, pars = "sigma")[idx,]
nu <- as.matrix(fit, pars = "nu")[idx,]
preds <- .pp_student(nu, mu, sigma)
}
if (family == "poisson") preds <- .pp_poisson(mu)
if (family == "binomial") preds <- .pp_binomial(mu, trials)
class(preds) <- append("ppd", class(preds))
return(preds)
}
posterior_predict
?geostan::waic
?stan_esf
?geostan::stan_esf
pkgs <- c("geostan", "INLA")
lapply(pkgs, require, character.only = TRUE)
data(sentencing)
C <- shape2mat(sentencing)
nbs <- edges(C)
head(nbs)
N = nrow(C)
#Build the adjacency matrix using INLA library functions
adj.matrix = sparseMatrix(i=nbs$node1,j=nbs$node2,x=1,symmetric=TRUE)
#The ICAR precision matrix (note! This is singular)
Q=  Diagonal(nbs$N, rowSums(adj.matrix)) - adj.matrix
#Add a small jitter to the diagonal for numerical stability (optional but recommended)
Q_pert = Q + Diagonal(nbs$N) * max(diag(Q)) * sqrt(.Machine$double.eps)
# Compute the diagonal elements of the covariance matrix subject to the
# constraint that the entries of the ICAR sum to zero.
#See the inla.qinv function help for further details.
Q_inv = inla.qinv(Q_pert, constr=list(A = matrix(1,1,nbs$N),e=0))
#Compute the geometric mean of the variances, which are on the diagonal of Q.inv
scaling_factor = exp(mean(log(diag(Q_inv))))
class(nbs)
#Build the adjacency matrix using INLA library functions
adj.matrix = sparseMatrix(i=nbs$node1,j=nbs$node2,x=1,symmetric=TRUE)
#The ICAR precision matrix (note! This is singular)
Q=  Diagonal(N, rowSums(adj.matrix)) - adj.matrix
#Add a small jitter to the diagonal for numerical stability (optional but recommended)
Q_pert = Q + Diagonal(N) * max(diag(Q)) * sqrt(.Machine$double.eps)
# Compute the diagonal elements of the covariance matrix subject to the
# constraint that the entries of the ICAR sum to zero.
#See the inla.qinv function help for further details.
Q_inv = inla.qinv(Q_pert, constr=list(A = matrix(1,1,N),e=0))
#Compute the geometric mean of the variances, which are on the diagonal of Q.inv
scaling_factor = exp(mean(log(diag(Q_inv))))
stan_bym2
fit <- stan_bym2(sents ~ offset(expected_sents),
data = sentencing@data,
C = C,
scaleFactor = scaling_factor,
chains = 1)
getwd()
setwd("dev/geostan")
devtools::load_all()
fit <- stan_bym2(sents ~ offset(expected_sents),
data = sentencing@data,
C = C,
scaleFactor = scaling_factor,
chains = 1)
devtools::load_all()
fit <- stan_bym2(sents ~ offset(expected_sents),
data = sentencing@data,
C = C,
scaleFactor = scaling_factor,
chains = 1)
fit
plot(fit)
plot(fit, pars = 'convolved_re', plotfun = 'dens')
plot(fit, 'sigma_re', plotfun = 'dens')
pkgs <- c("geostan", "INLA", "sf", "ggplot2")
lapply(pkgs, require, character.only = TRUE)
re <- as.matrix(fit, pars = "convolved_re")
sigma <- as.matrix(fit, pars = "sigma_re")
re[1,] * sigma[1,]
re[1,1] * sigma[1,1]
conv.re <- re * sigma
dim(sigma)
sweep(re, 2, sigma, "*")
sweep(re, 1, sigma, "*")
x <- sweep(re, 1, sigma, "*")
dim(x)
x[1,1]
re[2,1] * sigma[2]
x[2,1]
sf <- apply(x, 2, mean)
ggplot(st_as_sf(sentencing)) +
geom_sf(aes(fill = sf)) +
scale_fill_gradient2()
fit <- stan_esf(sents ~ offset(expected_sents),
data = sentencing@data,
C = C,
chains = 1)
ggplot(st_as_sf(sentencing)) +
geom_sf(aes(fill = spatial(fit)$mean)) +
scale_fill_gradient2()
fit <- stan_esf(sents ~ offset(expected_sents),
re = ~ name,
data = sentencing@data,
C = C,
chains = 1)
fit <- stan_esf(sents ~ offset(expected_sents),
re = ~ name,
family = poisson(),
data = sentencing@data,
C = C,
chains = 1)
re <- as.matrix(fit, pars = "alpha_re")
re <- apply(re, 2, mean)
sf <- spatial(fit)$mean + re
ggplot(st_as_sf(sentencing)) +
geom_sf(aes(fill = sf)) +
scale_fill_gradient2()
fit.bym2 <- stan_bym2(sents ~ offset(expected_sents),
data = sentencing@data,
C = C,
scaleFactor = scaling_factor,
chains = 1)
fit.esf=fit
waic(fit.bym2); waic(fit.esf)
fit.iar <- stan_icar(sents ~ offset(expected_sents),
re = ~ name,
family = poisson(),
data = sentencing@data,
C = C,
chains = 1)
waic(fit.bym2); waic(fit.esf); waic(fit.iar)
?stan_bym2
phi <- as.matrix(fit.bym2, "phi")
theta <- as.matrix(fit.bym2, "theta")
re2 <- phi + theta
dim(x)
dim(re2)
plot(x[1,], re2[1,])
abline(0,1)
re <- as.matrix(fit, pars = "convolved_re")
sigma <- as.matrix(fit, pars = "sigma_re")
x <- sweep(re, 1, sigma, "*")
sf <- apply(x, 2, mean)
phi <- as.matrix(fit.bym2, "phi")
theta <- as.matrix(fit.bym2, "theta")
re2 <- phi + theta
re <- as.matrix(fit.bym2, pars = "convolved_re")
sigma <- as.matrix(fit.bym2, pars = "sigma_re")
x <- sweep(re, 1, sigma, "*")
re <- as.matrix(fit.bym2, pars = "convolved_re")
sigma <- as.matrix(fit.bym2, pars = "sigma_re")
x <- sweep(re, 1, sigma, "*")
## this should be the same
phi <- as.matrix(fit.bym2, "phi")
theta <- as.matrix(fit.bym2, "theta")
re2 <- phi + theta
plot(x[1,], re2[1,])
abline(0,1)
plot(as.numeric(x), as.numeric(re2))
abline(0,1)
?stan_esf
?stan_icar
?stan_glm
phi=apply(phi,2,mean)
ggplot(st_as_sf(sentencing)) +
geom_sf(aes(fill = phi)) +
scale_fill_gradient2()
