% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stan_icar.R
\name{stan_icar}
\alias{stan_icar}
\title{Intrinsic autoregressive models}
\source{
Besag, J. (1974). Spatial interaction and the statistical analysis of lattice systems. Journal of the Royal Statistical Society: Series B (Methodological), 36(2), 192-225.

Besag, J., York, J., & Mollié, A. (1991). Bayesian image restoration, with two applications in spatial statistics. Annals of the institute of statistical mathematics, 43(1), 1-20.

Donegan, Connor. 2021. Flexible functions for ICAR, BYM, and BYM2 models in Stan. Code repository. <https://github.com/ConnorDonegan/Stan-IAR>

Freni-Sterrantino, Anna, Massimo Ventrucci, and Håvard Rue. 2018. A Note on Intrinsic Conditional Autoregressive Models for Disconnected Graphs. Spatial and Spatio-Temporal Epidemiology 26: 25–34.

Morris, M., Wheeler-Martin, K., Simpson, D., Mooney, S. J., Gelman, A., & DiMaggio, C. (2019). Bayesian hierarchical spatial models: Implementing the Besag York Mollié model in stan. Spatial and spatio-temporal epidemiology, 31, 100301.

Riebler, A., Sorbye, S. H., Simpson, D., & Rue, H. (2016). An intuitive Bayesian spatial model for disease mapping that accounts for scaling. Statistical Methods in Medical Research, 25(4), 1145-1165.
}
\usage{
stan_icar(
  formula,
  slx,
  re,
  data,
  type = c("icar", "bym", "bym2"),
  scale_factor = NULL,
  ME = NULL,
  C,
  family = poisson(),
  prior = NULL,
  prior_intercept = NULL,
  prior_tau = NULL,
  centerx = FALSE,
  scalex = FALSE,
  prior_only = FALSE,
  chains = 4,
  iter = 4000,
  refresh = 1000,
  pars = NULL,
  control = list(adapt_delta = 0.9, max_treedepth = 15),
  silent = FALSE,
  ...
)
}
\arguments{
\item{formula}{A model formula, following the R \link[stats]{formula} syntax. Binomial models can be specified by setting the left hand side of the equation to a data frame of successes and failures, as in \code{cbind(successes, failures) ~ x}.}

\item{slx}{Formula to specify any spatially-lagged covariates. As in, \code{~ x1 + x2} (the intercept term will be removed internally).
These will be pre-multiplied by a row-standardized spatial weights matrix and then added (prepended) to the design matrix.
If and when setting priors for \code{beta} manually, remember to include priors for any SLX terms as well.}

\item{re}{If the model includes a varying intercept term \code{alpha_re} specify the grouping variable here using formula syntax, as in \code{~ ID}. Then, \code{alpha_re ~ N(0, alpha_tau)}, \code{alpha_tau ~ Student_t(d.f., location, scale)}. Before using this, read the \code{Details} section and the \code{type} argument.}

\item{data}{A \code{data.frame} or an object coercible to a data frame by \code{as.data.frame} containing the model data.}

\item{type}{Defaults to "icar" (partial pooling of neighboring observations through parameter \code{phi}); specify "bym" to add a second parameter vector \code{theta} to perform partial pooling across all observations; specify "bym2" for the innovation introduced by Riebler et al. (2016). See \code{Details} for more information.}

\item{scale_factor}{For the BYM2 model, optional. If missing, this will be set to a vector of ones.}

\item{ME}{To model observational uncertainty (i.e. measurement or sampling error) in any or all of the covariates, provide a named list. Errors are assigned a Gaussian probability distribution and the modeled (true) covariate vector is assigned a Student's t model or, if \code{ME$spatial = TRUE}, an auto Gaussian (CAR) model. Elements of the list \code{ME} may include:
\describe{

\item{se}{a dataframe with standard errors for each observation; columns will be matched to the variables by column names. The names should match those from the output of \code{model.matrix(formula, data)}.}
\item{bounded}{If any variables in \code{se} are bounded within some range (e.g. percentages ranging from zero to one hundred) provide a vector of zeros and ones indicating which columns are bounded. By default the lower bound will be 0 and the upper bound 100, for percentages.}
\item{bounds}{A numeric vector of length two providing the upper and lower bounds, respectively, of any bounded variables.}
\item{spatial}{Logical value indicating whether an auto Gaussian (i.e., conditional autoregressive (CAR)) model should be used for the covariates. Defaults to \code{spatial = FALSE}. The specification of the auto Gaussian model is fixed such that any non-zero values in \code{C} will be converted to ones.}
}}

\item{C}{Spatial connectivity matrix which will be used to construct an edge list for the ICAR model, and to calculate residual spatial autocorrelation as well as any user specified \code{slx} terms or spatial measurement error (ME) models. It will automatically be row-standardized before calculating \code{slx} terms. \code{C} must be a binary symmetric \code{n x n} matrix.}

\item{family}{The likelihood function for the outcome variable. Current options are \code{binomial(link = "logit")} and \code{poisson(link = "log")}.}

\item{prior}{A \code{data.frame} or \code{matrix} with location and scale parameters for Gaussian prior distributions on the model coefficients. Provide two columns---location and scale---and a row for each variable in their order of appearance in the model formula. Default priors are weakly informative relative to the scale of the data.}

\item{prior_intercept}{A vector with location and scale parameters for a Gaussian prior distribution on the intercept; e.g. \code{prior_intercept = c(0, 10)}.}

\item{prior_tau}{Set hyperparameters for the scale parameter of exchangeable random effects/varying intercepts. The random effects are given a normal prior with scale parameter \code{alpha_tau}. The latter is given a half-Student's t prior with default of 20 degrees of freedom, centered on zero and scaled to the data to be weakly informative. To adjust it use, e.g., \code{prior_tau = c(df = 15, location = 0, scale = 5)}.}

\item{centerx}{Should the covariates be centered prior to fitting the model? Defaults to \code{FALSE}.}

\item{scalex}{Should the covariates be centered and scaled (divided by their standard deviation)? Defaults to \code{FALSE}.}

\item{prior_only}{Draw samples from the prior distributions of parameters only.}

\item{chains}{Number of MCMC chains to estimate.}

\item{iter}{Number of samples per chain. .}

\item{refresh}{Stan will print the progress of the sampler every \code{refresh} number of samples; set \code{refresh=0} to silence this.}

\item{pars}{Optional; specify any additional parameters you'd like stored from the Stan model.}

\item{control}{A named list of parameters to control the sampler's behavior. See \link[rstan]{stan} for details. The defaults are the same \code{rstan::stan} except that \code{adapt_delta} is raised to \code{.9} and \code{max_treedepth = 15}.}

\item{silent}{If \code{TRUE}, suppress printed messages including prior specifications and Stan sampling progress (i.e. \code{refresh=0}). Stan's error and warning messages will still print.}

\item{...}{Other arguments passed to \link[rstan]{sampling}. For multi-core processing, you can use \code{cores = parallel::detectCores()}, or run \code{options(mc.cores = parallel::detectCores())} first.}
}
\value{
An object of class class \code{geostan_fit} (a list) containing: 
\describe{
\item{summary}{Summaries of the main parameters of interest; a data frame}
\item{diagnostic}{Widely Applicable Information Criteria (WAIC) with crude measure of effective number of parameters (\code{eff_pars}) and 
 mean log pointwise predictive density (\code{lpd}), and residual spatial autocorrelation (Moran coefficient of the residuals). Residuals are relative to the mean posterior fitted values.}
\item{stanfit}{an object of class \code{stanfit} returned by \code{rstan::stan}}
\item{data}{a data frame containing the model data}
\item{edges}{The edge list representing all unique sets of neighbors and the weight attached to each pair (i.e., their corresponding element in the connectivity matrix  C}
\item{family}{the user-provided or default \code{family} argument used to fit the model}
\item{formula}{The model formula provided by the user (not including ICAR component)}
\item{slx}{The \code{slx} formula}
\item{re}{A list with two name elements, \code{formula} and \code{Data}, containing the formula \code{re} and a data frame with columns \code{id} (the grouping variable) and \code{idx} (the index values assigned to each group).}
\item{priors}{Prior specifications.}
\item{scale_params}{A list with the center and scale parameters returned from the call to \code{base::scale} on the model matrix. If \code{centerx = FALSE} and \code{scalex = FALSE} then it is an empty list.}
\item{spatial}{A data frame with the name of the spatial parameter (\code{"phi"} if \code{type = "icar"} else \code{"convolution"}) and method (\code{toupper(type)}).}
}
}
\description{
Assign the intrinsic conditional auto-regressive (ICAR) prior model to parameters. Options include the BYM model, the BYM2 model, and a solo ICAR term.
}
\details{
The Stan code for the ICAR component of the model and the BYM2 option follows Morris et al. (2019) with adjustments to enable non-binary weights and disconnected graph structures (see Freni-Sterrantino (2018) and Donegan (2021)). The ICAR parameters are returned in the parameter vector named \code{phi}. The ICAR prior model is equivalent to a CAR model with the spatial autocorrelation parameter \code{car_alpha} equal to 1 (see \link[geostan]{stan_car}). Thus the ICAR prior places high probability on a smooth spatially varying mean. Often, an observational-level random effect term \code{theta} is added to model deviations from the local mean. Use of the combination \code{phi + theta} is known as the BYM model (Besag et al. 1991). 

The ICAR prior is placed on the parameter vector \code{phi_tilde} (which is approximately on the standard normal scale); it is scaled by the scalar parameter \code{spatial_scale}. The models are specified as follows:

If \code{type = "icar"}, the spatial structure is simply \code{phi[i] = phi_tilde[i] * spatial_scale}.

If \code{type = "bym"}, the spatial structure \code{phi} is the same as \code{"icar"} but an additional parameter vector \code{theta} is added to perform partial pooling across all observations.  \code{theta[i] = theta_tilde[i] * theta_scale}. The sum \code{phi_tilde * spatial_scale + theta_tilde * theta_scale = phi + theta = convolution} is often referred to as the ``convolved random effect.'' 

For \code{type = "bym2"}, \code{phi_tilde} and \code{theta_tilde} share a single scale parameter (\code{spatial_scale}) but they are combined using a mixing parameter \code{rho}. The convolution is then \code{convolution = [sqrt(rho / scale_factor) * phi_tilde + sqrt((1 - rho)) * theta_tilde] * spatial_scale}. For convenience, the model will factor the convolution term into parameters \code{phi} and \code{theta}.

The actual calculation of the convolution term is specified to ensure that observations with zero neighbors, and disconnected graph structures, are handled properly. Following Freni-Sterrantino (2018), disconnected components of the graph structure are given their own intercept term; however, this value is added to phi automatically inside the Stan model. Therefore, the use never needs to make any adjustments for this term. The additional intercepts, when there are any, are returned in a parameter vector named `alpha_phi`.

For calculating the `scale_factor` introduced by Riebler et al. (2016), see Donegan (2021). The code in that repository shows how to (painlessly) calculate the scale factor for each connected component of the graph structure (and, again, follows Freni-Sterrantino (2018) and Morris et al. (2019)).
}
\examples{
\dontrun{
library(rstan)
library(bayesplot)
options(mc.cores = parallel::detectCores())
data(sentencing)

C <- shape2mat(sentencing)
log_e <- log(sentencing$expected_sents)
fit.bym <- stan_icar(sents ~ offset(log_e),
                     family = poisson(),
                     data = sentencing,
                     type = "bym",
                     C = C,
                     refresh = 0
 )

# diagnostics plot: Rhat values should all by very near 1
rstan::stan_rhat(fit.bym$stanfit)
 # see effective sample size for all parameters and generated quantities
 # (including residuals, predicted values, etc.)
rstan::stan_ess(fit.bym$stanfit)
# or for a particular parameter
rstan::stan_ess(fit.bym$stanfit, "phi")
library(bayesplot)
yrep <- posterior_predict(fit.bym, samples = 100)
y <- sentencing$sents
bayesplot::ppc_dens_overlay(y, yrep)
}

}
\seealso{
\link[geostan]{prep_icar_data}, \link[geostan]{shape2mat}, \link[geostan]{stan_car}, \link[geostan]{stan_esf}, \link[geostan]{stan_glm}
}
\author{
Connor Donegan, \email{Connor.Donegan@UTDallas.edu}
}
