% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stan_icar.R
\name{stan_icar}
\alias{stan_icar}
\title{ICAR}
\source{
Besag, J. (1974). Spatial interaction and the statistical analysis of lattice systems. Journal of the Royal Statistical Society: Series B (Methodological), 36(2), 192-225.

Morris, M., Wheeler-Martin, K., Simpson, D., Mooney, S. J., Gelman, A., & DiMaggio, C. (2019). Bayesian hierarchical spatial models: Implementing the Besag York Molli√© model in stan. Spatial and spatio-temporal epidemiology, 31, 100301.
}
\usage{
stan_icar(
  formula,
  slx,
  re,
  data,
  C,
  family = poisson(),
  prior = NULL,
  prior_intercept = NULL,
  prior_tau = NULL,
  prior_phi = 1,
  centerx = TRUE,
  scalex = FALSE,
  chains = 4,
  iter = 2000,
  refresh = 500,
  pars = NULL,
  control = list(adapt_delta = 0.9, max_treedepth = 15),
  ...
)
}
\arguments{
\item{formula}{A model formula, following the R \link[stats]{formula} syntax. If an offset term is provided for a Poisson model, it will be transformed to the log scale internally; to add an offset term \code{E} to a formula use \code{y ~ offset(E)}. Binomial models can be specified by setting the left hand side of the equation to a data frame of successes and failures, as in \code{cbind(successes, failures) ~ x}.}

\item{slx}{Formula to specify any spatially-lagged covariates. As in, \code{~ x1 + x2} (the intercept term will be removed internally).
These will be pre-multiplied by a row-standardized spatial weights matrix and then added (prepended) to the design matrix.
If and when setting priors for \code{beta} manually, remember to include priors for any SLX terms as well.}

\item{re}{If the model includes a varying intercept term (or "spatially unstructured random effect") specify the grouping variable here using formula synatax, as in \code{~ ID}. If this is specified at the observational unit level then it becomes the original Besag-York-Mollie model. In that case this random effects term and the ICAR component are not separately identifiable. The resulting random effects parameter returned is named \code{alpha_re}.}

\item{data}{A \code{data.frame} or an object coercible to a data frame by \code{as.data.frame} containing the model data.}

\item{C}{Spatial connectivity matrix which will be used to construct an edge list, and to calculate residual spatial autocorrelation as well as any user specified \code{slx} terms; it will be row-standardized before calculating \code{slx} terms.}

\item{family}{The likelihood function for the outcome variable. Current options are \code{binomial(link = "logit")} and \code{poisson(link = "log")}.}

\item{prior}{A \code{data.frame} or \code{matrix} with location and scale parameters for Gaussian prior distributions on the model coefficients. Provide two columns---location and scale---and a row for each variable in their order of appearance in the model formula. Default priors are weakly informative relative to the scale of the data.}

\item{prior_intercept}{A vector with location and scale parameters for a Gaussian prior distribution on the intercept; e.g. \code{prior_intercept = c(0, 10)}. When setting this prior, keep in mind that if \code{centerx = TRUE} (the default), then the intercept is the expected outcome when covariates are at their mean level.}

\item{prior_tau}{Set hyperparameters for the scale parameter of exchangeable random effects/varying intercepts. The random effects are given a normal prior with scale parameter \code{alpha_tau}. The latter is given a half-Student's t prior with default of 20 degrees of freedom, centered on zero and scaled to the data to be weakly informative. To adjust it use, e.g., \code{prior_tau = c(df = 15, location = 0, scale = 5)}.}

\item{prior_phi}{Prior for the scale of the spatial ICAR component \code{phi}. \code{phi} is scaled by the parameter \code{phi_scale} which is given a positively-constrained (half-) Gaussian prior distribution with its location parameter at zero and scale parameter set to \code{prior_phi}. This defaults to \code{prior_phi = 1}.}

\item{centerx}{Should the covariates be centered prior to fitting the model? Defaults to \code{TRUE}. This alters the interpretation of the intercept term, see \code{Details}) below.}

\item{scalex}{Should the covariates be scaled (divided by their standard deviation)? Defaults to \code{FALSE}.}

\item{chains}{Number of MCMC chains to estimate. Default \code{chains = 4}.}

\item{iter}{Number of samples per chain. Default \code{iter = 2000}.}

\item{refresh}{Stan will print the progress of the sampler every \code{refresh} number of samples. Defaults to \code{500}; set \code{refresh=0} to silence this.}

\item{pars}{Optional; specify any additional parameters you'd like stored from the Stan model.}

\item{control}{A named list of parameters to control the sampler's behavior. See \link[rstan]{stan} for details. The defaults are the same \code{rstan::stan} excep that \code{adapt_delta} is raised to \code{.9} and \code{max_treedepth = 15}.}

\item{...}{Other arguments passed to \link[rstan]{sampling}. For multi-core processing, you can use \code{cores = parallel::detectCores()}, or run \code{options(mc.cores = parallel::detectCores())} first.}
}
\value{
An object of class class \code{geostan_fit} (a list) containing: 
\describe{
\item{summary}{Summaries of the main parameters of interest; a data frame}
\item{diagnostic}{Widely Applicable Information Criteria (WAIC) with crude measure of effective number of parameters (\code{eff_pars}) and 
 mean log pointwise predictive density (\code{lpd}), and residual spatial autocorrelation (Moran coefficient of the residuals). Residuals are relative to the mean posterior fitted values.}
\item{stanfit}{an object of class \code{stanfit} returned by \code{rstan::stan}}
\item{data}{a data frame containing the model data}
\item{edges}{The edge list representing all unique sets of neighbors}
\item{family}{the user-provided or default \code{family} argument used to fit the model}
\item{formula}{The model formula provided by the user (not including ESF component)}
\item{slx}{The \code{slx} formula}
\item{re}{A list containing \code{re}, the random effects (varying intercepts) formula if provided, and 
 \code{Data} a data frame with columns \code{id}, the grouping variable, and \code{idx}, the index values assigned to each group.}
\item{priors}{Prior specifications.}
\item{scale_params}{A list with the center and scale parameters returned from the call to \code{base::scale} on the model matrix. If \code{centerx = FALSE} and \code{scalex = FALSE} then it is an empty list.}
\item{spatial}{A data frame with the name of the spatial component parameter ("phi") and method ("ICAR")}
}
}
\description{
Fit a regression model with an intrinsic conditional auto-regressive (ICAR) spatial component. Only fully connected graphs are currenlty supported (i.e. all polygons must have at least one neighbor and there can be no disconnected islands or regions).
}
\details{
If the \code{centerx = TRUE} (the default), then the intercept is the expected value of the outcome variable when 
  all of the covariates are at their mean value. 

 The Stan code for the ICAR component of the model follows Morris et al. (2019).
   
 The function returns the ICAR component in the parameter \code{phi}.
 The entire posterior distribution of \code{phi}
 can be obtained with the following code: \code{post_phi <- spatial(fit, summary = FALSE)} where \code{fit} is
 the \code{geostan_fit} object returned by a call to \code{stan_icar}. 
 
 When \code{family = student_t()}, the parameter \code{nu} in the model refers to the degrees of freedom in the Student's t likelihood function for the data.
}
\examples{
library(ggplot2)
library(sf)
library(rstan)
options(mc.cores = parallel::detectCores())
data(sentencing)

# using a small number of iterations and a single chain only for compilation speed
C <- shape2mat(sentencing)
fit.icar <- stan_icar(sents ~ offset(expected_sents), family = poisson(),
                     data = sentencing@data, C = C,
                    chains = 1, iter = 500)

# add exchangeable random effects (for a BYM model). See stan_bym2 for a better model.
fit.bym <- stan_icar(sents ~ offset(expected_sents), re = ~ name,
                     family = poisson(),
                     data = sentencing@data, C = C,
                     chains = 1, iter = 500)

# view WAIC 
waic(fit.icar)
waic(fit.bym)

# diagnostics plot: Rhat values should all by very near 1
library(rstan)
rstan::stan_rhat(fit.icar$stanfit)
 # see effective sample size for all parameters and generated quantities
 # (including residuals, predicted values, etc.)
rstan::stan_ess(fit.icar$stanfit)
# or for a particular parameter
rstan::stan_ess(fit.icar$stanfit, "phi")
library(bayesplot)
yrep <- posterior_predict(fit.icar, samples = 100)
y <- sentencing$sents
ppc_dens_overlay(y, yrep)
# map standardized incidence (sentencing) ratios
E <- sentencing$expected_sents
sentencing@data$ssr <- fitted(fit.bym)$mean / E
ggplot(data=st_as_sf(sentencing),
      aes(fill = ssr)) +
 geom_sf() +
 scale_fill_gradient2(midpoint = 1) +
 theme_bw() +
 ggtitle("Standardized state prison sentencing ratios, 1905-1910")

}
\author{
Connor Donegan, \email{Connor.Donegan@UTDallas.edu}
}
