% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/posterior_predict.R
\name{posterior_predict}
\alias{posterior_predict}
\title{Sample from the posterior predictive distribution}
\usage{
posterior_predict(
  object,
  newdata,
  W,
  samples,
  predictive = TRUE,
  re_form = NULL,
  spatial = TRUE,
  seed,
  centerx = FALSE,
  scalex = FALSE
)
}
\arguments{
\item{object}{A \code{geostan_fit} object.}

\item{newdata}{A \code{data.frame} or \code{matrix} with data to use for predictions. Must be named and the names must match the model formula.}

\item{W}{Spatial connectivity matrix for calculating spatially lagged covariates (slx), if needed. If the model has an slx term then \code{newdata} must have the same number of rows as the data used to fit the model.}

\item{samples}{Number of samples to take from the posterior distribution. Maximum is the total number of samples stored in the model.}

\item{predictive}{Return the predictive distribution? Defaults to \code{TRUE}. If \code{FALSE}, then the linear predictor is returned after applying the inverse link function.}

\item{re_form}{If \code{re_form = NA} any random effects terms will be ignored when making predictions. If default \code{re_form = NULL} is set, then the results will include random effects terms. Those are the only options; this syntax is used to maintain some consistency with other R packages which have additional options.}

\item{spatial}{Include the spatial component in the model predictions? Defaults to \code{TRUE} and will be ignored if the model does not have a spatial comonent (i.e. \code{\link[geostan]{stan_glm}}). For models fit by \code{\link[geostan]{stan_esf}}, \code{\link[geostan]{stan_icar}}, and \code{\link[geostan]{stan_bym2}} this option requires that \code{newdata} have the same number of observations as the data that the model was fit to.}

\item{seed}{A single integer value to be used in a call to \code{\link[base]{set.seed}} before taking samples from the posterior distribution. Passing a value to \code{seed} enables you to obtain the same results each time (by using the same seed).}

\item{centerx}{Should \code{newdata} be centered using the means of the variables in the original data used to fit the model (stored in \code{fit$scale_params})? Defaults to \code{FALSE}.}

\item{scalex}{Should \code{newdata} be scaled using the standard deviations of the variables in the original data used to fit the model (stored in \code{fit$scale_params})? Defaults to \code{FALSE}.}
}
\value{
A matrix of size \code{S} x \code{N} containing samples from the posterior predictive distribution, where \code{S} is the number of samples and \code{N} is the number of observations. It is of class \code{matrix} and \code{ppd}.
}
\description{
Draw samples from the posterior predictive distribution of a fitted \code{geostan} model. Use the original data or new data, with or without the spatial component and random effects terms.
}
\examples{
library(bayesplot)
library(ggplot2)
library(sf)
data(ohio)
## fit Ohio election model with a spatial filter
fit <- stan_esf(gop_growth ~ log(pop_density) + historic_gop + college_educated,
                data = ohio,
                family = student_t(),
                C = shape2mat(ohio, "B"),
                iter = 400, chains = 1)

## posterior predictive check (density overlay)
## compare distribution of observations to the predictive distribution
y <- ohio$gop_growth
yrep <- posterior_predict(fit, samples = 150)
ppc_dens_overlay(y, yrep)

## model convict-leasing era sentencing risk in Florida
data(sentencing)
C <- shape2mat(sentencing)
fit <- stan_esf(sents ~ offset(expected_sents),
              ##  re = ~ name,
                data = sentencing,
                family = poisson(),
                C = C,
                chains = 1, iter = 400)
## posterior predictive checks
yrep <- posterior_predict(fit, samples = 200, seed = 1)
 # density overlay
ppc_dens_overlay(sentencing$sents, yrep)
 # map realizations from the model, as relative risk  
fl <- st_as_sf(sentencing)
E <- fl$expected_sents
map_pp <- function(i) {
   ggplot(fl) +
   geom_sf(aes(fill = yrep[i,] / E)) +
   scale_fill_gradient2(midpoint = 1) +
   theme_void()
}
map_pp(1)
map_pp(20)
map_pp(90)

}
